# RGB거리에 있는 n개의 집을 빨강, 초록, 파랑 중 하나의 색으로 칠함. 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값?
# 규칙 1. 1번의 집의 색은 2번의 집의 색과 같지 않다. 규칙2. n번 집의 색은 n - 1집의 색과 같지 않다. 규칙 3. i(2<= i <= n-1)번 집의 색은 i - 1번 i + 1번 집의 색과 같지 않음.
# 입력 첫째줄 -> 집의 수 n, 입력 둘째줄 ~ n번째 -> 빨강, 초록, 파랑으로 칠하는 비용이 1번집 부터 한줄에 하나씩. 집 칠하는 비용은 1000보다 작거나 같은 자연수
# 출려 첫째줄 -> 모든 집을 칠하는 최솟값

# 최솟값 저장해 나가면서 모든 집 칠할 때 의 최솟값
# n x3의 2차원 배열 만들기. DP[0][0]은 첫번째 집의 R비용, DP[0][1]에는 첫번째 집의 G비용, DP[0][2]에는 첫번째 집의 B비용 정리
# 다음 집부터는 전집과 다른 색을 칠해야 하므로 앞집에서 선택 한 색을 체외하고 최솟값 선택해서 더하기

n = int(input()) #집의 수 입력받기

cost = [] #각 집 칠하는 비용 나열하기
minCost = -int(1e9) #최소값 최소 설정
dp = [[0] * 3 for _ in range(n)] #배열 만들기
for i in range(n): #집의 수 만큼 나열
    cost.append(list(map(int, input().split()))) #돈 배열에 맞춰서 나열하기

dp[0][0], dp[0][1], dp[0][2] = cost[0][0], cost[0][1], cost[0][2]

for i in range(1, n): #각 배열마다 비용 구하기
    dp[i][0] = min(dp[i - 1][1] + cost[i][0], dp[i - 1][2] + cost[i][0])
    dp[i][1] = min(dp[i - 1][0] + cost[i][1], dp[i - 1][2] + cost[i][1])
    dp[i][2] = min(dp[i - 1][0] + cost[i][2], dp[i - 1][1] + cost[i][2])

print(min(dp[n - 1][0], dp[n - 1][1], dp[n - 1][2])) #배열에서 구한 값으로 최솟값 찾기