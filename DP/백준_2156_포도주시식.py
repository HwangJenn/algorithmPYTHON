# 테이블 위에 일렬로 놓인 포도주를 규칙에 따라 맛보되 최대한 많이 맛보는 방법
# 규칙 1. 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 함. 규칙 2. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.
# 1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어짐.
# 입력 첫째줄 -> 포도주 잔의 개수 n (1 <= n <= 10,000), 입력 둘째 줄 -> n + 1번째 줄까지 포도주 잔에 들어있는 포도주의 양(1,000이하의 음이 아닌 정수)
# 출력 첫째줄 -> 최대로 마실 수 있는 포도주의 양
# 힌트) 6개의 포도주 잔, 포도주의 양: 6 10 13 9 8 1 , 첫번째 두번째 네번째 다섯번째 선택하면 총 포도주 양으로 33으로 최대로 마실 수 있다.

# 힌트 바탕으로 생각하면 6 10 13 9 8 1의 포도주 잔이 있다고 하면 마지막 포도주 선택 상황을 가정핮자.
# 연속으로 놓인 3잔을 못마시는 규칙2에 따라 이미 9 와 8을 마셨으면 1을 마실 수 없고 13 9 를 마셨다면 1을 마실 수 있다.
# 따라서, 1) 현재 포도주와 이젖 포도주를 마시고 전전 포도주는 마시지 않는다. ( wine[i] + wine[i - 1] + d[i - 3])
# 2) 현재 포도주와 전전 포도주를 마시고 이전포도주는 마시지 않는다. (wine[i] - d[i - 2])
# 3) 현재 포도주를 마시지 않는다. (d[i - 1]) -> d[i - 2] + wine[i - 1] 이 아닌 d[i - 1]이라고 한 이유는 해당 케이스를 포함한 최댓값이저장되어 있기 때문.

n = int(input()) #포도잔의 개수 입력받기

wine = [] #순서대로 주어질 포도주의 양 정렬하기

for i in range(n): #포도주잔의 개수만큼 반복
    wine.append(int(input())) #포도주의 양 입력받기

d = [0] * n #포도주 마시는 방법의 수
d[0] = wine[0]

# 포도잔이 3잔 이하인 경우에는 인덱스 에러를 방지하기 위해 예외처리를 먼저 해준다.
if n > 1:
    d[1] = wine[0] + wine[1]

if n > 2:
    d[2] = max(wine[2] + wine[1], wine[2] + wine[0], d[1])

for i in range(3, n): #포도주가 3잔이상이고 n잔 이하일 때
    d[i] = max(d[i - 1], d[i - 3] + wine[i - 1] + wine[i], d[i - 2] + wine[i]) #포도주를 최대로 마시기

print(d[n - 1]) #포도주를 마지막으로 마시지 않는 시점이 최대