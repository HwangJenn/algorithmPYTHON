# 나이트가 이동하려고 하는 칸이 주어 질 때, 나이트가 몇 번 움직여야 이 칸으로 이동 할수 있나?
# 입력 첫째 줄 -> 테스트 케이스의 개수, 케이스 첫째 줄 -> 체스판 한 변 길이 l, 케이스 둘째 줄 -> 현재 위치 하는 칸, 케이스 셋째 줄 -> 이동하려는 칸
# 출력 -> 각 테스트 케이스마다 나이트가 이동가능한 최소의 횟변
# 나이트가 한번에 이동 할 수 있는 칸: 왼1위2, 오1위2, 오2위1, 오2,아1, 오1아2, 왼1아2, 왼2아1, 왼2위1

# 이동 좌표 설정 후 이동 반복문 반복이동한다.
# 1부터 시작하기 때문에, 이동 시 이전 값 +1 저장, 목적지 좌표가 나오면 -1한 값 리턴한다.
# 이동 좌표 제외하고 다른 bfs문제와 동일하다.

# 파이썬 Queue는 deque로 사용해 구현한다
from collections import deque #파이썬에 내장된 collections 에서 deque 수입.

# 나이트의 이동방향 미리 입력
dx = [-1, -2, -2, -1, 1, 2, 2, 1]
dy = [2, 1, -1, -2, -2, -1, 1, 2]

n = int(input()) #테스트 케이스의 개수 입력받기

#이동 좌표 설정
for i in range(n): #테스트 케이스 개수(n) 만큼 반복한다.
    l = int(input()) #체스판 한 변의 길이 입력받기
    graph = [] # 2차원 리스트를 통해 구현 할 체스판, 이동 횟수 기록
    for i in range(l): #체스판 크기 만큼 반복
        graph.append([0] * l) #(lxl)체스판이므로 [0]*l 만큼의 열 각 행마다 l번 추가
    #bfs
    queue = deque() #queue에 deque로 초기화
    x, y = map(int, input().split()) #'시작 위치' 입력
    w, z = map(int, input().split()) #'목표 위치' 입력
    queue.append((x, y)) #시작위치 deque에 입력
    while queue: #queue(deque) 내에 아무것도 남지 않을 때 까지 반복
        x, y = queue.popleft() #deque 맨왼쪽에 있는 좌표 꺼내서 x, y 위치에 매핑

        if x == w and y == z: # 꺼낸 좌표가 목표지점과 비교해서 같으면
            break #while문 탈출
        ''''시작위치를 계산이후에도 사용하려면, 시작 위치를 입력 받자마자 다른 변수에 저장한다.
        계산과정 진행으로 x, y 값은 계속해서 변경 될 것이다.
        현재위치가 목표위치에 도달하는 순간 while문 멈춘다.
        이 조건이 없는 경우 그래프의 모든 경우의 수 구하는 것이므로 시간초과로 이어질 수 있는 불필요한 연산이 많아진다.'''
        for i in range(8): #햔재 위치 기준으로 8방향 모두 구하기
            #현재 값 + 이동 값 = 신규위치
            nx = x + dx[i]
            ny = y + dy[i]

            if nx < 0 or ny < 0 or nx >= l or ny >= l: #신규위치가 체스판 안에 존재하지 않는다면
                continue # 해당사항 건너뛰고 위 for문 반복한다.
            if graph[nx][ny] == 0: #한번도 방문하지 않았다면
                graph[nx][ny] = graph[x][y] + 1 #신규위치는 현재 좌표 +1값임
                queue.append((nx,ny)) #w,z좌표에서 값 출력한다.
    print(graph[w][z]) #나이트가 움직여야 할 좌표